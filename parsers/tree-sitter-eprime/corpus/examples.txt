==============
Car Sequencing
==============
language ESSENCE' 1.0
given numcars : int(1..)
given numclasses : int(1..)
given numoptions : int(1..)
given optMax : matrix indexed by [ int(1..numoptions) ] of int(0..)
given windowSize : matrix indexed by [ int(1..numoptions) ] of int(0..)
given optionsRequired : matrix indexed by [ int(1..numclasses), int(1..numoptions) ] of bool
given numberPerClass : matrix indexed by [ int(1..numclasses) ] of int(1..)

$ Decision variables
find seq: matrix indexed by [ int(1..numcars) ] of int(1..numclasses) 
such that
forAll option : int(1..numoptions) .
    forAll windowStart : int(1..numcars-windowSize[option]+1) .
        (sum pos : int(windowStart..windowStart+windowSize[option]-1) .
            seq[pos] in toSet([ class | class : int(1..numclasses), optionsRequired[class, option]])
        )<=optMax[option],
        
forAll option : int(1..numoptions) .
    (sum pos : int(1..numcars) .
        seq[pos] in toSet([ class | class : int(1..numclasses), optionsRequired[class, option]])
    )=
    (
        sum class : int(1..numclasses) . optionsRequired[class, option]*numberPerClass[class]
    ),
 
gcc(seq, [ i | i : int(1..numclasses)], numberPerClass)
---

(source_file
(lang_version)
(param_decl
(identifier)
(integer_domain
    (range_literal
    (integer_literal))))
(param_decl
(identifier)
(integer_domain
    (range_literal
    (integer_literal))))
(param_decl
(identifier)
(integer_domain
    (range_literal
    (integer_literal))))
(param_decl
(identifier)
(matrix_domain
    (integer_domain
    (range_literal
        (integer_literal)
        (identifier)))
    (integer_domain
    (range_literal
        (integer_literal)))))
(param_decl
(identifier)
(matrix_domain
    (integer_domain
    (range_literal
        (integer_literal)
        (identifier)))
    (integer_domain
    (range_literal
        (integer_literal)))))
(param_decl
(identifier)
(matrix_domain
    (integer_domain
    (range_literal
        (integer_literal)
        (identifier)))
    (integer_domain
    (range_literal
        (integer_literal)
        (identifier)))
    (boolean_domain)))
(param_decl
(identifier)
(matrix_domain
    (integer_domain
    (range_literal
        (integer_literal)
        (identifier)))
    (integer_domain
    (range_literal
        (integer_literal)))))
(line_comment)
(decision_decl
(identifier)
(matrix_domain
    (integer_domain
    (range_literal
        (integer_literal)
        (identifier)))
    (integer_domain
    (range_literal
        (integer_literal)
        (identifier)))))
(constraint
(quantification
    (identifier)
    (generator
    (identifier)
    (integer_domain
        (range_literal
        (integer_literal)
        (identifier))))
    (quantification
    (identifier)
    (generator
        (identifier)
        (integer_domain
        (range_literal
            (integer_literal)
            (infix_operator
            (infix_operator
                (identifier)
                (indexed_access
                (identifier)
                (identifier)))
            (integer_literal)))))
    (infix_operator
        (quantification
        (identifier)
        (generator
            (identifier)
            (integer_domain
            (range_literal
                (identifier)
                (infix_operator
                (infix_operator
                    (identifier)
                    (indexed_access
                    (identifier)
                    (identifier)))
                (integer_literal)))))
        (set_in
            (indexed_access
            (identifier)
            (identifier))
            (call
            (identifier)
            (matrix_comprehension
                (identifier)
                (generator
                (identifier)
                (integer_domain
                    (range_literal
                    (integer_literal)
                    (identifier))))
                (indexed_access
                (identifier)
                (identifier)
                (identifier))))))
        (indexed_access
        (identifier)
        (identifier)))))
(quantification
    (identifier)
    (generator
    (identifier)
    (integer_domain
        (range_literal
        (integer_literal)
        (identifier))))
    (infix_operator
    (quantification
        (identifier)
        (generator
        (identifier)
        (integer_domain
            (range_literal
            (integer_literal)
            (identifier))))
        (set_in
        (indexed_access
            (identifier)
            (identifier))
        (call
            (identifier)
            (matrix_comprehension
            (identifier)
            (generator
                (identifier)
                (integer_domain
                (range_literal
                    (integer_literal)
                    (identifier))))
            (indexed_access
                (identifier)
                (identifier)
                (identifier))))))
    (quantification
        (identifier)
        (generator
        (identifier)
        (integer_domain
            (range_literal
            (integer_literal)
            (identifier))))
        (infix_operator
        (indexed_access
            (identifier)
            (identifier)
            (identifier))
        (indexed_access
            (identifier)
            (identifier))))))
(call
    (identifier)
    (identifier)
    (matrix_comprehension
    (identifier)
    (generator
        (identifier)
        (integer_domain
        (range_literal
            (integer_literal)
            (identifier)))))
    (identifier))))

===================
All-Interval Series
===================

$ Model created by Hakan Kjellerstrand, hakank@gmail.com
$ See also my Essence'/Tailor page: http://www.hakank.org/savile_row/
$ Licenced under CC-BY-4.0 : http://creativecommons.org/licenses/by/4.0/
 
language ESSENCE' 1.0
 
letting n be 12
letting range be domain int(1..n)
letting range2 be domain int(1..n-1)
find x: matrix indexed by [range] of range
find diffs: matrix indexed by [range2] of range2
 
such that
   allDiff(diffs),
   allDiff(x),
   forall k : range2 . diffs[k] = |x[k+1]-x[k]|,
   x
   x[1] < x[n-1],
   diffs[1] < diffs[2]
---

(source_file
(line_comment)
(line_comment)
(line_comment)
(lang_version)
(const_def
(identifier)
(integer_literal))
(domain_alias
(identifier)
(integer_domain
    (range_literal
    (integer_literal)
    (identifier))))
(domain_alias
(identifier)
(integer_domain
    (range_literal
    (integer_literal)
    (infix_operator
        (identifier)
        (integer_literal)))))
(decision_decl
(identifier)
(matrix_domain
    (identifier)
    (identifier)))
(decision_decl
(identifier)
(matrix_domain
    (identifier)
    (identifier)))
(constraint
(call
    (identifier)
    (identifier))
(call
    (identifier)
    (identifier))
(quantification
    (identifier)
    (generator
    (identifier)
    (identifier))
    (infix_operator
    (indexed_access
        (identifier)
        (identifier))
    (absolute_operator
        (infix_operator
        (indexed_access
            (identifier)
            (infix_operator
            (identifier)
            (integer_literal)))
        (indexed_access
            (identifier)
            (identifier))))))
(infix_operator
    (indexed_access
    (identifier)
    (ERROR
        (identifier))
    (integer_literal))
    (indexed_access
    (identifier)
    (infix_operator
        (identifier)
        (integer_literal))))
(infix_operator
    (indexed_access
    (identifier)
    (integer_literal))
    (indexed_access
    (identifier)
    (integer_literal)))))

===================
Number Partitioning
===================
$ This Essence' model was created by Hakan Kjellerstrand, hakank@gmail.com .
$ See also my Tailor/Essence' page: http://www.hakank.org/savile_row/ .
$ Licenced under CC-BY-4.0 : http://creativecommons.org/licenses/by/4.0/
 
language ESSENCE' 1.0
 
letting n be 16
letting num_sets be 2
find a: matrix indexed by [int(1..n)] of int(1..num_sets)
 
find sums: matrix indexed by [int(1..num_sets)] of int(0..n*n)
find sums_squared: matrix indexed by [int(1..num_sets)] of int(0..n*n*n*n)
 
such that
   forall i: int(1..num_sets) .
       sums[i] = (sum j: int(1..n) . j*(a[j]=i)) /\
       sums_squared[i] = sum j: int(1..n) . j**2*(a[j]=i)
   ,
   $ same cardinality and sums
   forall i: int(2..num_sets) .
      (sum j: int(1..n) . a[j]=i-1) = (sum j: int(1..n) . a[j]=i) /\
      sums[i-1] = sums[i] /\
      sums_squared[i-1] = sums_squared[i]
   ,
   $ summetry breaking
   a[1] = 1

---
(source_file
      (line_comment)
      (line_comment)
      (line_comment)
      (lang_version)
      (const_def
        (identifier)
        (integer_literal))
      (const_def
        (identifier)
        (integer_literal))
      (decision_decl
        (identifier)
        (matrix_domain
          (integer_domain
            (range_literal
              (integer_literal)
              (identifier)))
          (integer_domain
            (range_literal
              (integer_literal)
              (identifier)))))
      (decision_decl
        (identifier)
        (matrix_domain
          (integer_domain
            (range_literal
              (integer_literal)
              (identifier)))
          (integer_domain
            (range_literal
              (integer_literal)
              (infix_operator
                (identifier)
                (identifier))))))
      (decision_decl
        (identifier)
        (matrix_domain
          (integer_domain
            (range_literal
              (integer_literal)
              (identifier)))
          (integer_domain
            (range_literal
              (integer_literal)
              (infix_operator
                (infix_operator
                  (infix_operator
                    (identifier)
                    (identifier))
                  (identifier))
                (identifier))))))
      (constraint
        (quantification
          (identifier)
          (generator
            (identifier)
            (integer_domain
              (range_literal
                (integer_literal)
                (identifier))))
          (infix_operator
            (infix_operator
              (indexed_access
                (identifier)
                (identifier))
              (quantification
                (identifier)
                (generator
                  (identifier)
                  (integer_domain
                    (range_literal
                      (integer_literal)
                      (identifier))))
                (infix_operator
                  (identifier)
                  (infix_operator
                    (indexed_access
                      (identifier)
                      (identifier))
                    (identifier)))))
            (infix_operator
              (indexed_access
                (identifier)
                (identifier))
              (quantification
                (identifier)
                (generator
                  (identifier)
                  (integer_domain
                    (range_literal
                      (integer_literal)
                      (identifier))))
                (infix_operator
                  (infix_operator
                    (identifier)
                    (integer_literal))
                  (infix_operator
                    (indexed_access
                      (identifier)
                      (identifier))
                    (identifier)))))))
        (line_comment)
        (quantification
          (identifier)
          (generator
            (identifier)
            (integer_domain
              (range_literal
                (integer_literal)
                (identifier))))
          (infix_operator
            (infix_operator
              (infix_operator
                (quantification
                  (identifier)
                  (generator
                    (identifier)
                    (integer_domain
                      (range_literal
                        (integer_literal)
                        (identifier))))
                  (infix_operator
                    (indexed_access
                      (identifier)
                      (identifier))
                    (infix_operator
                      (identifier)
                      (integer_literal))))
                (quantification
                  (identifier)
                  (generator
                    (identifier)
                    (integer_domain
                      (range_literal
                        (integer_literal)
                        (identifier))))
                  (infix_operator
                    (indexed_access
                      (identifier)
                      (identifier))
                    (identifier))))
              (infix_operator
                (indexed_access
                  (identifier)
                  (infix_operator
                    (identifier)
                    (integer_literal)))
                (indexed_access
                  (identifier)
                  (identifier))))
            (infix_operator
              (indexed_access
                (identifier)
                (infix_operator
                  (identifier)
                  (integer_literal)))
              (indexed_access
                (identifier)
                (identifier)))))
        (line_comment)
        (infix_operator
          (indexed_access
            (identifier)
            (integer_literal))
          (integer_literal))))

======
Sudoku
======

language ESSENCE’ 1.0
find M : matrix indexed by [int(1..9), int(1..9)] of int(1..9)
such that
M[1,1]=5,
M[1,2]=3,
M[1,5]=7,
....
M[9,9]=9,
forAll row : int(1..9) .
forAll col1 : int(1..9) .
forAll col2: int(col1+1..9) . M[row, col1]!=M[row, col2],
forAll col : int(1..9) .
forAll row1 : int(1..9) .
forAll row2: int(row1+1..9) . M[row1, col]!=M[row2, col]


---

(source_file
      (lang_version)
      (decision_decl
        (identifier)
        (matrix_domain
          (integer_domain
            (range_literal
              (integer_literal)
              (integer_literal)))
          (integer_domain
            (range_literal
              (integer_literal)
              (integer_literal)))
          (integer_domain
            (range_literal
              (integer_literal)
              (integer_literal)))))
      (constraint
        (infix_operator
          (indexed_access
            (identifier)
            (integer_literal)
            (integer_literal))
          (integer_literal))
        (infix_operator
          (indexed_access
            (identifier)
            (integer_literal)
            (integer_literal))
          (integer_literal))
        (infix_operator
          (indexed_access
            (identifier)
            (integer_literal)
            (integer_literal))
          (integer_literal))
        (ERROR)
        (infix_operator
          (indexed_access
            (identifier)
            (integer_literal)
            (integer_literal))
          (integer_literal))
        (quantification
          (identifier)
          (generator
            (identifier)
            (integer_domain
              (range_literal
                (integer_literal)
                (integer_literal))))
          (quantification
            (identifier)
            (generator
              (identifier)
              (integer_domain
                (range_literal
                  (integer_literal)
                  (integer_literal))))
            (quantification
              (identifier)
              (generator
                (identifier)
                (integer_domain
                  (range_literal
                    (infix_operator
                      (identifier)
                      (integer_literal))
                    (integer_literal))))
              (infix_operator
                (indexed_access
                  (identifier)
                  (identifier)
                  (identifier))
                (indexed_access
                  (identifier)
                  (identifier)
                  (identifier))))))
        (quantification
          (identifier)
          (generator
            (identifier)
            (integer_domain
              (range_literal
                (integer_literal)
                (integer_literal))))
          (quantification
            (identifier)
            (generator
              (identifier)
              (integer_domain
                (range_literal
                  (integer_literal)
                  (integer_literal))))
            (quantification
              (identifier)
              (generator
                (identifier)
                (integer_domain
                  (range_literal
                    (infix_operator
                      (identifier)
                      (integer_literal))
                    (integer_literal))))
              (infix_operator
                (indexed_access
                  (identifier)
                  (identifier)
                  (identifier))
                (indexed_access
                  (identifier)
                  (identifier)
                  (identifier))))))))

==============
Traffic Lights
==============
$ CSPLib problem 16
$ http://www.csplib.org/Problems/prob016
$ This Essence' model was created by Hakan Kjellerstrand, hakank@gmail.com
$ See also my Essence' page: http://www.hakank.org/savile_row/
$ Licenced under CC-BY-4.0 : http://creativecommons.org/licenses/by/4.0/
 
language ESSENCE' 1.0
 
 
letting n  be 4
letting range be domain int(1..n)
 
letting r  be 1 $ red
letting ry be 2 $ red-yellow
letting g  be 3 $ green
letting y  be 4 $ yellow
 
letting allowed =
   [
     [r,r,g,g],
     [ry,r,y,r],
     [g,g,r,r],
     [y,r,ry,r]
   ]
 
letting Cars be domain int(r,ry,g,y)
letting Pedestrians be domain int(r,g)
 
$ decision variables
find V: matrix indexed by [range] of Cars
find P: matrix indexed by [range] of Pedestrians
 
such that
  forall i, j: range .
       (j = (1+i) % 4) => table([V[i], P[i], V[j], P[j]], allowed)
---

(source_file)

==============
Traffic Lights2
==============
language ESSENCE' 1.0
 
letting noSteps be 51
letting STEPS be domain int(0..noSteps)
letting STEPS1 be domain int(1..noSteps)
 
letting SPADES be 0
letting HEARTS be 1
letting CLUBS be 2
letting DIAMONDS be 3
 
letting CARDS_NO_ACE be domain int(1..51)
letting SUITS be domain int(0..3)
letting CARDS be domain int(0..51)
 
$  Cards are numbered 0 -- ace of spades, 1 -- 2 of spades...  13 -- ace of hearts etc.
 
given initialStacks : matrix indexed by [int(0..50)] of CARDS_NO_ACE
 
$ the sequence of ranks for each step
find blackHole : matrix indexed by [STEPS] of CARDS
$ the cards and their position in the sequence
find cardSequence : matrix indexed by [CARDS] of STEPS
 
$ height 3: topmost card
$ height 2: middle card
$ height 1: lowest card
$find height : matrix indexed by [CARDS_NO_ACE] of int(1..3)
 
 
such that
 
$ initial state: the spades ace in the middle
blackHole[0] = 0,
cardSequence[0] = 0,
 
allDiff(cardSequence),
allDiff(blackHole),
 
forAll step : STEPS1 .
   (|blackHole[step-1] - blackHole[step]| % 13 in {1,12}),
 
$   table([blackHole[step-1],blackHole[step]], CONSECUTIVE_CARD_TABLE),
 
 
$ precedence constraint
forAll card : int(0..50) .
   (card % 3 != 2) ->
      (cardSequence[initialStacks[card]] < cardSequence[initialStacks[card+1]]),
 
 
$ channelling constraint
forAll step : STEPS .
  forAll card : CARDS .
     (blackHole[step] = card) <-> (cardSequence[card] = step),
 
 
 
 
 
$ conditional symmetry breaking
 
 
$ if two cards of the same rank are on the bottom of a stack then take the smaller one
$ CASE A of Barbara's model
false ->
forAll stack1, stack2 : int(0..16) .
      ( (stack1 < stack2) /\  $ the 3rd cards have the same rank
        (initialStacks[stack1*3+2] % 13 = initialStacks[stack2*3+2] % 13)
      ) ->
 
             $ y[cover[c1] < y[c2]   ->  y[c1] < y[c2]
        (   (cardSequence[initialStacks[stack1*3+1]] < cardSequence[initialStacks[stack2*3+2]]
                 ) ->
            (cardSequence[initialStacks[stack1*3+2]] < cardSequence[initialStacks[stack2*3+2]])  
        ),
 
 
$ if two cards of the same rank are on top of a stack
$ CASE B of Barbara's model
false ->
forAll stack1, stack2 : int(0..16) .
      ( (stack1 < stack2) /\  $ the 1st cards have the same rank
        (initialStacks[stack1*3] % 13 = initialStacks[stack2*3] % 13)
      ) ->
 
             $ y[c1] < y[coveredby[c2]]  ->  y[c1] < y[c2]
        (  ( cardSequence[initialStacks[stack1*3]] < cardSequence[initialStacks[stack2*3+1]] 
                 ) ->
             ( cardSequence[initialStacks[stack1*3]] < cardSequence[initialStacks[stack2*3]] )
            
        ),
 
$ 2 cards are in the middle
$ CASE C of Barbara's model
false ->
forAll stack1, stack2 : int(0..16) .
    ( (stack1 < stack2)  /\  $ different stacks and cards in the midle are of the same rank
            (initialStacks[stack1*3+1] % 13 = initialStacks[stack2*3+1] % 13)
    ) ->
       $ (y[c1] < y[coveredby[c2]  &&  y[cover[c1]] < y[c2] )  ->  y[c1] < y[c2]
    ( ( (cardSequence[initialStacks[stack1*3+1]] < cardSequence[initialStacks[stack2*3+2]]) /\
        (cardSequence[initialStacks[stack1*3]] < cardSequence[initialStacks[stack2*3+1]])
      )  ->
         ( cardSequence[initialStacks[stack1*3+1]] < cardSequence[initialStacks[stack2*3+1]])
    ),
 
 
$ if two cards have the same rank and one is on top and the other the last of a stack take the top one first
$ CASE D in Barbara's model
false ->
forAll stack1, stack2 : int(0..16) .
    ( (stack1 != stack2)  /\  $ different stacks and cards on top of stack1 and bottom of stack2 are of the same rank
            (initialStacks[stack1*3] % 13 = initialStacks[stack2*3+2] % 13)
    ) ->
        ( cardSequence[initialStacks[stack1*3]] < cardSequence[initialStacks[stack2*3+2]]),
 
 
$ ADDs more SEARCH for instance 106
$ one card on top, the other in the middle
$ CASE E in barbara's model
false ->
forAll stack1, stack2 : int(0..16) .
    ( (stack1 != stack2)  /\  $ different stacks and cards on top of stack1 and middle of stack2 are of the same rank
            (initialStacks[stack1*3] % 13 = initialStacks[stack2*3+1] % 13)
    ) ->
       (   $ y[c1] < y[coveredby[c2] && y[c2] < y[coveredby[c1]]  -> y[c1] < y[c2]
         ( (cardSequence[initialStacks[stack1*3]] < cardSequence[initialStacks[stack2*3+2]] ) /\
           (cardSequence[initialStacks[stack2*3+1]] < cardSequence[initialStacks[stack1*3+1]] )
         ) ->
          ( cardSequence[initialStacks[stack1*3]] < cardSequence[initialStacks[stack2*3+1]])
      ),
 
 
$ one card in middle, other on bottom
$ CASE F in barbara's model
false ->
forAll stack1, stack2 : int(0..16) .
    ( (stack1 != stack2)  /\
            (initialStacks[stack1*3+1] % 13 = initialStacks[stack2*3+2] % 13)
    ) ->
       (   $ y[cover[c1]] < y[c2] && y[cover[c2]] < y[c1]  -> y[c1] < y[c2]
         ( (cardSequence[initialStacks[stack1*3]] < cardSequence[initialStacks[stack2*3+2]] ) /\
           (cardSequence[initialStacks[stack2*3+1]] < cardSequence[initialStacks[stack1*3+1]] )
         ) ->
          ( cardSequence[initialStacks[stack1*3+1]] < cardSequence[initialStacks[stack2*3+2]])
      )
---

(source_file)

=======
Test
=======

such that
forAll step : STEPS1 .
   (|blackHole[step-1] - blackHole[step]| % 13 in {1,12})


letting x be |blackHole[step-1] - blackHole[step]| % 13 in 5
---

(source_file)
