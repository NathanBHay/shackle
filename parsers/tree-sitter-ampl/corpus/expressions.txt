========
Indexing
========

{A};
{A, B};
{i in A, j in B};
{i in A, B};
{i in A, C[i]};
{i in A, (j,k) in D};
{i in A: p[i] > 0};
{i in A, j in C[i]: i <= j};
{i in A, (i,j) in D: i <= j};

---

(source_file
    item: (indexing
        (identifier))
    item: (indexing
        (identifier)
        (identifier))
    item: (indexing
        (infix_operator
            left: (identifier)
            right: (identifier))
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (indexing
        (infix_operator
            left: (identifier)
            right: (identifier))
        (infix_operator
            left: (identifier)
            right: (identifier))))

==============
Unary Operator
==============

let x := -x;
let y := +y;
let z := not z;

---

(source_file
    item: (let_decl
        name: (identifier)
        (unary_operator
            operand: (identifier)))
    item: (let_decl
        name: (identifier)
        (unary_operator
            operand: (identifier)))
    item: (let_decl
        name: (identifier)
        (unary_operator
            operand: (identifier))))

==============
Infix Operator
==============

let a := x + 1;
let b := x - 1;
let c := x * 1;
let d := x / 1;
let e := x less 1;
let f := x mod 1;
let h := x ^ y;
let i := x ** y;
let j := x * y;
let k := x / y;
let l := x div y;
let m := x..y;
let n := x .. y by z;
let o := x = y;
let p := x == y;
let q := x != y;
let r := x < y;
let s := x <> y;
let t := x <= y;
let u := x symdiff y;
let v := x diff y;
let w := x union y;
let x := x in y;
let y := x cross y;
let z := x and y;

---

(source_file
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (number_literal)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (number_literal)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (number_literal)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (number_literal)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (number_literal)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (number_literal)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (infix_operator
                left: (identifier)
                right: (identifier))
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier)))
    item: (let_decl
        name: (identifier)
        (infix_operator
            left: (identifier)
            right: (identifier))))

============
if-then-else
============

let x := if x < 2 then 1 else 0;
let y := if x < 2 then 1;
let z := if not true then 1 else 0;

---
(source_file
    item: (let_decl
        name: (identifier)
        (if_then_else
            condition: (infix_operator
                left: (identifier)
                right: (number_literal))
            result: (number_literal)
            else: (number_literal)))
    item: (let_decl
        name: (identifier)
        (if_then_else
            condition: (infix_operator
                left: (identifier)
                right: (number_literal))
            result: (number_literal)))
    item: (let_decl
        name: (identifier)
        (if_then_else
            condition: (unary_operator
                operand: (boolean_literal))
            result: (number_literal)
            else: (number_literal))))

=============
Function Call
=============

let x := func(a,b,c);
let y := func2(a < 4, not b);
let z := func_second();

---

(source_file
    item: (let_decl
        name: (identifier)
        (function_call
            function: (identifier)
            argument: (identifier)
            argument: (identifier)
            argument: (identifier)))
    item: (let_decl
        name: (identifier)
        (function_call
            function: (identifier)
            argument: (infix_operator
                left: (identifier)
                right: (number_literal))
            argument: (unary_operator
                operand: (identifier))))
    item: (let_decl
        name: (identifier)
        (function_call
            function: (identifier))))

==================
Reduction Operator
==================

let x := sum {y in Y} y;
let y := min {j in A} j;
let z := forall {i in A, j in A} i * j;

---

(source_file
    item: (let_decl
        name: (identifier)
        (reduction
            indexing: (indexing
                (infix_operator
                    left: (identifier)
                    right: (identifier)))
            expression: (identifier)))
    item: (let_decl
        name: (identifier)
        (reduction
            indexing: (indexing
                (infix_operator
                    left: (identifier)
                    right: (identifier)))
            expression: (identifier)))
    item: (let_decl
        name: (identifier)
        (reduction
            indexing: (indexing
                (infix_operator
                    left: (identifier)
                    right: (identifier))
                (infix_operator
                    left: (identifier)
                    right: (identifier)))
            expression: (infix_operator
                left: (identifier)
                right: (identifier)))))